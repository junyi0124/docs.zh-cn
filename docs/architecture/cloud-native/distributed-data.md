---
title: 分布式数据
description: 整体和云本机应用程序中的数据存储对比。
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: b7c8c43b16f2f70f9009c4fe4a8d19c52fa7ea2a
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/24/2020
ms.locfileid: "91163929"
---
# <a name="distributed-data"></a>分布式数据

正如我们在本书中看到的那样，云本机方法会改变设计、部署和管理应用程序的方式。 它还更改了管理和存储数据的方式。

图5-1 对比不同之处。

![云本机应用程序中的数据存储](./media/distributed-data.png)

**图 5-1**。 云中的数据管理-本机应用程序

经验丰富的开发人员可以轻松地识别出图5-1 左侧的体系结构。 在此 *单一应用程序*中，业务服务组件归置在一个共享服务层中，共享单个关系数据库中的数据。

在许多方面，单一数据库将数据管理保持简单。 跨多个表查询数据非常简单。 对数据更新一起或全部回滚。 [ACID 事务](/windows/desktop/cossdk/acid-properties) 保证了强和即时一致性。

为云本机设计，我们采用不同的方法。 在图5-1 的右侧，请注意企业功能如何分隔开来到小型、独立的微服务中。 每个微服务都封装了特定的业务功能及其自身的数据。 单一数据库分解到分布式数据模型中，其中包含许多较小的数据库，每个数据库都与微服务对齐。 冒烟清除时，会出现一个 *按微服务公开数据库*的设计。

## <a name="database-per-microservice-why"></a>每微服务数据库，为什么？

此数据库的每个微服务都有很多好处，特别是对于必须迅速发展并支持大规模扩展的系统。 具有此模型 .。。

- 域数据封装在服务中
- 数据架构可在不直接影响其他服务的情况下进行发展
- 每个数据存储可以独立缩放
- 一项服务中的数据存储故障不会直接影响其他服务

分离数据还允许每个微服务实现最适合其工作负荷、存储需求和读/写模式的数据存储类型。 选项包括关系、文档、键-值甚至基于图形的数据存储区。

图5-2 显示了云本机系统中 polyglot 持久性的原则。

![Polyglot 数据暂留](./media/polyglot-data-persistence.png)

**图 5-2**。 Polyglot 数据暂留

请注意，上图中的每个微服务如何支持不同类型的数据存储。

- 产品目录微服务使用关系数据库来容纳其基础数据的丰富关系结构。
- 购物车微服务使用一种分布式缓存，该缓存支持其简单的键-值数据存储。
- 排序微服务同时使用 NoSql 文档数据库来执行写入操作，同时使用高度非规范化的键/值存储来容纳大量读取操作。
  
尽管关系数据库仍适用于使用复杂数据的微服务，但 NoSQL 数据库已经获得了相当多的普及。 它们提供巨大的规模和高可用性。 它们的无架构性质使开发人员可以从类型化的数据类和 Orm 的体系结构中消失，这会使更改成本高昂且非常耗时。 本章稍后将介绍 NoSQL 数据库。

 虽然将数据封装到单独的微服务可以提高灵活性、性能和可伸缩性，但也会带来许多挑战。 在下一部分中，我们将讨论这些挑战以及模式和实践，以帮助解决这些问题。  

## <a name="cross-service-queries"></a>跨服务查询

尽管微服务是独立的，并且侧重于特定功能功能（如库存、发货或排序），但它们常常需要与其他微服务集成。 通常，集成涉及到一个 *查询* 数据的微服务。 图5-3 显示了该方案。

![跨微服务进行查询](./media/cross-service-query.png)

**图 5-3**。 跨微服务进行查询

在上图中，我们看到一个购物篮微服务，它将商品添加到用户的购物篮中。 尽管此微服务的数据存储包含购物篮和行项目数据，但它不会保留产品或定价数据。 而这些数据项由目录和定价微服务拥有。 这会带来问题。 购物篮在其数据库中没有产品或定价数据时，如何微服务将产品添加到用户的购物篮？

第4章中所述的一个选项是从购物篮到目录和定价微服务的 [直接 HTTP 调用](service-to-service-communication.md#queries) 。 但是，在第4章，我们说同步 HTTP *调用微服务* 在一起，从而减少了其独立性并降低了其体系结构的优势。

还可以实现请求-答复模式，其中每个服务都有单独的入站和出站队列。 但是，这种模式很复杂，需要进行管道来关联请求和响应消息。
尽管这会将后端微服务调用分离，但调用服务仍必须同步等待调用完成。 网络拥塞、暂时性故障或过载的微服务，并可能导致长时间运行甚至失败的操作。

相反，删除跨服务依赖项的广泛接受模式是 [具体化视图模式](/azure/architecture/patterns/materialized-view)，如图5-4 所示。

![具体化视图模式](./media/materialized-view-pattern.png)

**图 5-4**。 具体化视图模式

使用此模式，可以将本地数据表 (称为 " *读取模型* ") 在购物篮服务中。 此表包含产品和定价微服务所需的数据的非规范化副本。 直接将数据复制到购物篮微服务，无需昂贵的跨服务呼叫。 利用服务的本地数据，可以提高服务的响应时间和可靠性。 此外，拥有自己的数据副本使购物篮服务更具弹性。 如果目录服务不可用，则不会直接影响购物篮服务。 购物篮可以继续处理自己的存储中的数据。

使用此方法时，你的系统中现在已有重复的数据。 但是，在云本机系统中进行 *战略* 复制的数据是一种已建立的做法，不会被视为反模式或不良做法。 请记住， *一个且仅有一个服务* 可以拥有一个数据集，并且拥有其权限。 更新记录的系统时，需要同步读取模型。 通常通过使用 [发布/订阅模式](service-to-service-communication.md#events)的异步消息传送来实现同步，如图5.4 所示。

## <a name="distributed-transactions"></a>分布式事务

当跨微服务查询数据很困难时，跨多个微服务实现事务甚至更加复杂。 在不同微服务中跨独立数据源维护数据一致性的固有挑战不能 understated。 云本机应用程序中缺少分布式事务意味着必须以编程方式管理分布式事务。 从一开始就是， *immediate consistency*从一开始就是*最终的一致性*。

图5-5 显示了问题。

![Saga 模式中的事务](./media/saga-transaction-operation.png)

**图 5-5**。 跨微服务实现事务

在上图中，五个独立的微服务参与了创建订单的分布式事务。 每个微服务都维护其自己的数据存储，并为其存储区实现本地事务。 若要创建顺序， *每个* 单独微服务的本地 *事务必须成功，否则必须* 中止并回滚操作。 虽然内置事务支持在每个微服务中均可用，但不支持跨所有五个服务的分布式事务，使数据保持一致。

相反，你必须 *以编程方式*构造此分布式事务。

用于添加分布式事务支持的常见模式是 Saga 模式。 这是通过以编程方式将本地事务组合在一起并按顺序调用每个事务来实现的。 如果任何本地事务失败，Saga 将中止该操作并调用一组 [补偿事务](/azure/architecture/patterns/compensating-transaction)。 补偿事务撤消前面的本地事务所做的更改，并还原数据一致性。 图5-6 显示了具有 Saga 模式的失败的事务。

![在 saga 模式中回滚](./media/saga-rollback-operation.png)

**图 5-6**。 回滚事务

在上图中，清单微服务中的 *更新清单* 操作失败。 Saga 调用 (为红色) 的一组补偿事务来调整清单计数、取消付款和订单，并将每个微服务的数据返回到一致的状态。

Saga 模式通常编排为一系列相关事件，或作为一组相关命令进行协调。 第4章介绍了服务聚合器模式，这种模式会成为协调 saga 实现的基础。 我们还讨论了如何将事件与 Azure 服务总线和 Azure 事件网格主题结合使用，这是编排 saga 实现的基础。

## <a name="high-volume-data"></a>大容量数据

大型云本机应用程序通常支持大容量数据需求。 在这些情况下，传统的数据存储技术可能会导致瓶颈。 对于大规模部署的复杂系统，命令和查询责任分离 (CQRS) 和事件源可能会提高应用程序性能。  

### <a name="cqrs"></a>CQRS

[CQRS](/azure/architecture/patterns/cqrs)是一种体系结构模式，有助于最大程度地提高性能、可伸缩性和安全性。 此模式分隔从写入数据的操作读取数据的操作。

对于普通方案，相同的实体模型和数据存储库对象 *同时* 用于读取和写入操作。

但是，在读取和写入时，大容量数据方案可以从单独的模型和数据表中获益。 为了提高性能，读取操作可以查询数据的高度非规范化表示形式，以避免产生昂贵的重复表联接和表锁。 *写入*操作（称为*命令*）会针对保证一致性的数据的完全标准化表示形式进行更新。 然后，需要实现一种机制来使这两种表示形式保持同步。通常，每当修改写入表时，它都会发布一个将修改复制到读取表的事件。

图5-7 显示了 CQRS 模式的实现。

![命令和查询责任分离](./media/cqrs-implementation.png)

**图 5-7**。 CQRS 实现

在上图中，实现了单独的命令和查询模型。 每个数据写入操作都会保存到写存储，然后传播到读取存储。 请密切注意数据传播过程如何以 [最终一致性](https://www.cloudcomputingpatterns.org/eventual_consistency/)原则运行。 读取模型最终与写入模型同步，但在此过程中可能会有一些延迟。 我们将在下一节中介绍最终的一致性。

这种分离使读取和写入可以独立缩放。 读取操作使用为查询优化的架构，而写入操作使用针对更新进行优化的架构。 读取查询针对非规范化数据，而复杂业务逻辑可应用于写入模型。 同样，对写入操作的安全性可能比公开读取操作的安全性更严格。

实现 CQRS 可以提高云本机服务的应用程序性能。 不过，它确实会导致设计更为复杂。 仔细并策略性地将此原则应用于云本机应用程序中将会从中受益的部分。 有关 CQRS 的详细信息，请参阅 Microsoft 书籍 [.Net 微服务：适用于容器化 .Net 应用程序的体系结构](../microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns.md)。

### <a name="event-sourcing"></a>事件溯源

优化大容量数据方案的另一种方法涉及到 [事件来源](/azure/architecture/patterns/event-sourcing)。

系统通常存储数据实体的当前状态。 例如，如果用户更改了其电话号码，则会用新编号更新客户记录。 我们始终知道数据实体的当前状态，但每个更新都会覆盖以前的状态。

在大多数情况下，此模型正常工作。 然而，在高容量系统中，事务锁定和频繁更新操作的开销可能会影响数据库性能、响应能力和限制可伸缩性。

事件源采用不同的方法来捕获数据。 影响数据的每个操作都将持久保存到事件存储区中。 我们不会更新数据记录的状态，而是将每个更改追加到过去事件的顺序列表中-类似于会计师的分类帐。 事件存储区成为数据的记录系统。 它用于在微服务的绑定上下文内传播各种具体化视图。 图5.8 显示模式。

![事件溯源](./media/event-sourcing.png)

**图 5-8**。 事件溯源

在上图中，请注意如何将用户购物车的每个条目 (为蓝色) 附加到基础事件存储。 在相邻的具体化视图中，系统将通过重播与每个购物车关联的所有事件来投影当前状态。 然后，将此视图或读取模型公开回 UI。 事件还可以与外部系统和应用程序集成，或查询以确定实体的当前状态。 利用此方法，你可以保留历史记录。 您不仅知道实体的当前状态，还知道您如何达到此状态。

在机械上，事件来源简化了写入模式。 没有更新或删除。 将每个数据项追加为不可变事件，可最大程度地减少争用、锁定和与关系数据库相关的并发冲突。 通过利用具体化视图模式生成读取模型，可以将视图与写入模型分离，并选择最佳数据存储以优化应用程序 UI 的需求。

对于此模式，请考虑直接支持事件源的数据存储。 Azure Cosmos DB、MongoDB、Cassandra、CouchDB 和 RavenDB 是良好的候选项。

与所有模式和技术一样，在需要时实现战略和。 尽管事件源可以提供更高的性能和可伸缩性，但这会降低复杂性和学习曲线。

>[!div class="step-by-step"]
>[上一页](service-mesh-communication-infrastructure.md)
>[下一页](relational-vs-nosql-data.md)
