---
title: 针对 .NET Framework 4.5 的 Windows Communication Foundation 词汇表
ms.date: 03/30/2017
helpviewer_keywords:
- Windows Communication Foundation [WCF], glossary
- WCF [WCF], glossary
ms.assetid: 39cd36f4-8a28-4d0b-a830-98d55c9d30ae
ms.openlocfilehash: cbd5ce06698400152460af0706761d9855b43e12
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "61929527"
---
# <a name="windows-communication-foundation-glossary-for-net-framework-45"></a>针对 .NET Framework 4.5 的 Windows Communication Foundation 词汇表

针对 Windows Communication Foundation 文档定义了以下术语。

## <a name="terms"></a>术语

|术语|定义|
|----------|----------------|
|地址|地址用于指定接收消息的位置。 地址以统一资源标识符 (URI) 的形式指定。 URI 架构部分指定用于到达地址的传输机制，如 HTTP 和 TCP。 URI 的层次结构部分包含一个唯一的位置，其格式取决于传输机制。|
|application endpoint（应用程序终结点）|一个终结点，由应用程序公开并对应于该应用程序实现的服务协定。|
|行为|行为是控制服务、终结点、特定操作或客户端的各种运行时特性的要素。 行为按照范围进行分组：常见行为在全局范围内影响所有终结点，服务行为仅影响与服务相关的方面，终结点行为仅影响与终结点相关的属性，操作级行为影响特定操作。|
|绑定|定义用于与 WCF 服务进行通信的通信协议。 它由一组称为绑定元素的要素构造而成，这些元素一个个地叠起来形成通信基础结构。  请参见“终结点”。|
|channel（通道）|通道是绑定元素的具体实现。 绑定表示配置，而通道是与该配置相关联的实现。 因此，每个绑定元素都有一个相关联的通道。 通道堆叠在一起以形成绑定的具体实现：通道堆栈。|
|claims-based security（基于声明的安全性）|允许基于声明对受保护资源进行授权访问。|
|client application（客户端应用程序）|客户端应用程序是与一个或多个终结点交换消息的程序。 客户端应用程序可通过创建 WCF 客户端的实例和调用该 WCF 客户端的方法来启动。 需要注意的是，单个应用程序既可以充当客户端，也可以充当服务。|
|编码|通过代码编写，开发人员可以对服务或客户端的所有组件进行严格控制，他们不仅能够对通过配置完成的所有设置进行检查，还能够根据需要利用代码将其重写。 可以通过代码编写、配置或将两者结合在一起对应用程序进行控制。|
|配置|配置的优点在于，它使非开发人员（如网络管理员）可以在代码编写完成后直接对客户端和服务参数进行设置，而不必重新进行编译。 使用配置不仅可以设置值（如终结点地址），还可以通过添加终结点、绑定和行为来实施进一步的控制。 可以通过配置、代码编写或将两者结合在一起对应用程序进行控制。|
|Contract — 协定|协定是对其所属的特定协定类型的支持规范。 例如，服务协定是一组操作的规范。 在 WCF 中，协定具有一个层次结构，此结构在 System.ServiceModel.Description 命名空间的说明对象中进行了镜像。 服务协定是 WCF 中最大的协定范围。 服务协定中的每个服务操作都具有一个操作协定，用于指定该操作可以交换的消息（包括错误消息）以及交换的方向。 操作中的每条消息都具有一个消息协定（即 SOAP 消息信封的结构规范），而每个消息协定又都具有一个数据协定，用于指定消息中包含的数据结构。|
|数据协定|服务使用的数据类型必须在元数据中进行描述，以使其他各方可以与该服务进行交互操作。 数据类型的说明称为数据协定，而这些类型可以在消息的任何部分使用（例如，作为参数或返回类型）。 如果服务仅使用简单类型，则无需显式使用数据协定。|
|declarative application（声明性应用程序）|具有充分的描述以便无需运行命令性指令即可在运行时创建的应用程序。|
|endpoint（终结点）|包含一个地址、一个绑定和一个用于与 WCF 服务进行通信的协定。|
|endpoint address（终结点地址）|您可以为服务中的每个终结点均创建一个具有唯一性的终结点地址，还可以在一定的条件下跨多个终结点共享一个地址。|
|fault contract（错误协定）|可以将错误协定与服务操作进行关联，以指示可能返回到调用方的错误。 一个操作可以具有零个或更多个与其相关联的错误。 这些错误是在编程模型中作为异常建模的 SOAP 错误。 这些异常将转换为 SOAP 错误，然后可以发送到客户端。|
|承载|服务必须承载于某个进程中。 宿主是控制服务的生存期的应用程序。 服务可以是自承载的，也可以由现有的宿主进程进行管理。|
|承载进程|托管进程是专为承载服务而设计的应用程序。 这些宿主进程包括 Internet 信息服务 (IIS)、Windows 激活服务 (WAS) 和 Windows 服务。 在这些宿主方案中，由宿主控制服务的生存期。 例如，使用 IIS 可以设置包含服务程序集和配置文件的虚拟目录。 在收到消息时，IIS 将启动服务并控制服务的生存期。|
|initiating operation（启动操作）|作为新会话的第一个操作而调用的操作。 只有在已调用至少一个启动操作之后才可以调用非启动操作。|
|instancing model（实例化模型）|每个服务都具有一个实例化模型。 有三种实例化模式：&quot;单个，&quot;单个 CLR 对象服务中的所有客户端;&quot;每次调用，&quot;在其中一个新的 CLR 对象创建的以处理每个客户端调用; 并&quot;每个会话，&quot;中的一组 CLR 对象创建，另一个用于每个单独的会话。 实例化模型的选择取决于应用程序需求和服务的预期使用模式。|
|消息|消息是一个独立的数据单元，它可能由几个部分组成，包括消息正文和消息头。|
|消息协定|消息协定描述消息的格式。 例如，它会声明消息元素应包含在消息头中还是包含在消息正文中，应该对消息的何种元素应用何种级别的安全性，等等。|
|消息安全模式|消息安全模式指定通过实现一种或多种安全规范来保证安全。 每个消息都包含必要的安全机制，用于在消息传输过程中保证安全，并使接收方能够检测到篡改和对消息进行解密。 从这种意义上说，安全信息包装在每个消息中，从而提供了跨多个跃点的端到端安全。 由于安全信息成为消息的一部分，因此还可以在消息中包含多种凭据（这些凭据称为“声明”）。 这种方法还具有这样一个优点，即消息可以通过任意传输协议（包括在其起点和目标之间的多个传输协议）安全地传送。 这种方法的缺点在于所使用的加密机制较为复杂，使性能受到影响。|
|元数据|服务的元数据描述服务的各种特征，外部实体需要了解这些特征以便与该服务进行通信。 ServiceModel 元数据实用工具 (Svcutil.exe) 可以使用元数据生成 WCF 客户端以及客户端应用程序用来与服务进行交互的伴随配置。  服务所公开的元数据包括 XML 架构文档（用于定义服务的数据协定）和 WSDL 文档（用于描述服务的方法）。  启用元数据后，WCF 可通过检查服务及其终结点来自动生成服务的元数据。 若要发布服务的元数据，必须显式启用元数据行为。|
|操作协定|操作协定定义参数和操作的返回类型。 在创建定义服务协定的接口时，可以通过将 T:System.ServiceModel.OperationContractAttribute 属性应用于协定中包含的每个方法定义来表示一个操作协定。 可以将操作建模为采用单个消息作为参数并返回单个消息，或者建模为采用一组类型作为参数并返回一个类型。 在后一种情况下，将由系统来确定需要为该操作交换的消息的格式。|
|Projection — 投影|网络上的数据的表示形式。 例如，SOAP 投影会作为 SOAP 信封发送消息；Web 投影会以 JSON 格式发送消息。|
|安全性|WCF 中的安全性包括保密性（为防止窃听而进行的消息加密）、完整性（用于检测消息篡改行为的方法）、身份验证（用于验证服务器和客户端的方法）以及授权（资源访问控制）。 通过利用现有安全机制（如 TLS over HTTP，也称为 HTTPS）或通过实现各种 WS-* 安全规范中的一个或多个规范，可以提供这些功能。|
|自我承载的服务|自承载服务是在开发人员创建的进程应用程序中运行的服务。 开发人员控制服务的生存期、设置服务的属性、打开服务（这会将服务设置为侦听模式）以及关闭服务。|
|服务|公开一个或多个终结点的程序或进程，其中每个终结点都会公开一个或多个操作。|
|service contract（服务协定）|服务协定将多个相关的操作联系在一起，组成单个功能单元。 协定可以定义服务级设置，如服务的命名空间、对应的回调协定以及其他此类设置。 在大多数情况下，协定的定义方法是用所选的编程语言创建一个接口，然后将 T:System.ServiceModel.ServiceContractAttribute 属性应用于该接口。 通过实现该接口，可生成实际的服务代码。|
|服务操作|服务操作是在服务的代码中定义的过程，用于实现某种操作的功能。 此操作作为 WCF 客户端上的方法向客户端公开。 该方法可能返回一个值，并可能采用数量可选的参数，或是不采用任何参数且不返回任何响应。 例如，作为一个操作&quot;Hello&quot;可以用作客户端存在并可以开始的一系列操作的通知。|
|系统提供的绑定|WCF 包含许多系统提供的绑定。 这些绑定是针对特定方案进行优化的绑定元素的集合。 例如，T:System.ServiceModel.WSHttpBinding 是为了与实现各种 WS* 规范的服务进行互操作而专门设计的。 通过仅提供那些可以正确应用于特定方案的选项，这些绑定可以节省时间。 如果其中的某个绑定不能满足您的需求，也可以创建您自己的自定义绑定。|
|terminating operation（终止操作）|作为现有会话的最后一个消息而调用的操作。 默认情况下，在关闭与服务相关联的会话之后，WCF 会回收服务对象及其上下文。|
|传输安全模式|可以通过以下三种模式之一来保证安全：传输模式、消息安全模式和使用消息凭据的传输模式。 传输安全模式指定由传输层机制（如 HTTPS）提供保密性、完整性和身份验证。 在使用像 HTTPS 这样的传输协议时，此模式的优点在于性能出色，而且由于它在 Internet 上非常流行，因此很容易理解。 此方法的缺点是这种安全分别应用于通信路径，这使得通信容易遭受中每个跃点&quot;中间人&quot;攻击。|
|使用消息凭据的传输安全模式|此模式使用传输层来提供消息的保密性、身份验证和完整性，并且每个消息都可以包含消息接收方所要求的多个凭据（声明）。|
|type converter（类型转换器）|CLR 类型可以与一个或多个 System.ComponentModel.TypeConverter 派生类型关联，这些派生类型使 CLR 类型的实例与其他类型的实例之间能够互相转换。 类型转换器使用 System.ComponentModel.TypeConverterAttribute 特性的 CLR 类型的与相关联。  可以在 CLR 类型或属性上直接指定 TypeConverterAttribute。 在属性上指定的类型转换器始终优先于在属性的 CLR 类型上指定的类型转换器。|
|WCF client（WCF 客户端）|WCF 客户端是一个客户端应用程序构造，可将服务操作作为方法公开（使用所选的 .NET Framework 编程语言，如 Visual Basic 或 Visual C#）。 任何应用程序都可以承载 WCF 客户端，包括承载服务的应用程序。 因此，可以创建一个包含其他服务的 WCF 客户端的服务。  使用 ServiceModel 元数据实用工具 (Svcutil.exe) 并将其指向正在运行的元数据发布服务，可以自动生成 WCF 客户端。|
|工作流服务|工作流服务是作为工作流实现的 WCF 服务。 工作流包含发送和/或接收 WCF 消息的消息传递活动。|
|WS-*|一组不断增加的、在 WCF 中实现的 Web 服务 (WS) 规范（如 WS-Security、WS-ReliableMessaging 等）的简写。|
|XAML|可扩展应用程序标记语言|
|XAML schema（XAML 架构）|用于在 XAML 中定义的自定义类型的标记架构。|
