---
title: 身份验证的扩展保护概述
ms.date: 03/30/2017
ms.assetid: 3d2ceffe-a7bf-4bd9-a5a2-9406423bd7f8
ms.openlocfilehash: 0537e6147a7b43dabcb4c3612fc58da11dfd4d6d
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/26/2020
ms.locfileid: "96255541"
---
# <a name="extended-protection-for-authentication-overview"></a>身份验证的扩展保护概述

身份验证的扩展保护有助于抵御中间人 (MITM) 攻击，在此类攻击中，攻击者截获客户端凭据并将它们转发给服务器。  
  
 假设有这么一种情况，有三个参与者：客户端、服务器和攻击者。 服务器的 URL 为 `https://server`，而攻击者的 URL 为 `https://attacker`。 攻击者诱骗客户端访问攻击者，就好像它是服务器。 然后，攻击者向服务器发送一个请求。 如果攻击者尝试访问安全资源，则服务器会使用 WWW-Authenticate 标头答复攻击者。 由于攻击者没有身份验证信息，因此它会将 WWW-Authenticate 标头发送给客户端。 客户端将 Authorization 标头发送给攻击者，然后，攻击者将此标头发送给服务器，并使用客户端凭据获取对安全资源的访问权限。  
  
 目前，当客户端应用程序通过 HTTPS 使用 Kerberos、Digest 或 NTLM 向服务器验证自身的身份时，首先会建立一个传输层安全 (TLS) 通道，然后使用此通道进行身份验证。 但是，安全套接字层 (SSL) 生成的会话密钥和身份验证期间生成的会话密钥之间没有任何绑定。 因此，在前面的情况中，如果通过 TLS（如 HTTPS 通道）进行通信，则会创建两个 SSL 通道：一个用于客户端与攻击者之间的通信，另一个用于攻击者与服务器之间的通信。 首先，通过客户端与攻击者之间的 SSL 通道从客户端发送客户端凭据，然后再通过攻击者与服务器之间的通道将凭据发送至服务器。 在客户端凭据到达服务器之后，服务器会验证凭据，而不检测通过其发送这些凭据的通道源自攻击者，而不是客户端。  
  
 解决方案是使用受 TLS 保护的外部通道和对客户端进行身份验证的内部通道，并将通道绑定令牌 (CBT) 传递给服务器。 CBT 是受 TLS 保护的外部通道的属性，并且用于通过对客户端进行身份验证的内部通道将外部通道绑定到对话。  
  
 在前面的情况中，客户端-攻击者 TSL 通道的 CBT 与发送给服务器的授权信息合并。 识别 CBT 的服务器将客户端身份验证信息中所含的 CBT（与客户端-攻击者通道相对应）与附加到攻击者-服务器通道的 CBT 进行比较。 CBT 特定于通道目标，因此客户端-攻击者 CBT 与攻击者-服务器 CBT 不匹配。 这样，服务器就可检测 MITM 攻击并拒绝身份验证请求。  
  
 客户端不需要任何配置设置。 在对客户端进行了更新以将 CBT 传递给服务器之后，它会始终执行此操作。 如果也对服务器进行了更新，则可以对其进行配置以使用 CBT 或忽略它。 如果未对服务器进行更新，则它会忽略 CBT。  
  
 服务器可以具有以下级别的保护：  
  
- 无。 不执行任何通道绑定验证。 这是所有尚未更新的服务器的行为。  
  
- 部分支持。 所有已更新的客户端必须向服务器提供通道绑定信息。 尚未更新的客户端无需执行此操作。 这是一个中间选项，可以实现应用程序兼容。  
  
- 已满。 所有客户端都必须提供通道绑定信息。 服务器拒绝来自不提供通道绑定信息的客户端的身份验证请求。  
  
 有关更多信息，请参见 Win7 CBT/扩展保护示例。  
  
## <a name="see-also"></a>另请参阅

- [Windows Server App Fabric 的安全模型](/previous-versions/appfabric/ee677202(v=azure.10))
